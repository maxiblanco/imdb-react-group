
.grid {
  display: grid;
  grid-gap: var(--s-2);
/*   justify-content: center;
  align-items: center;
  grid-template-columns: 100%; */
  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));  
}

/* .grid.aboveMin {
  grid-template-columns: repeat(auto-fill, minmax(calc(--measure/3), 1fr));
}

@supports (width: min(20%, 100%)) {
  .grid {
    grid-template-columns: repeat(auto-fit, minmax(min(calc(--measure/3), 100%), 1fr));  
  }
} */

//* BASE HTML */

/* 
<div class="grid" data-min="20rem">
  <div><!-- child element --></div>
  <div><!-- another child element --></div>
  <div><!-- etc --></div>
</div>
*/

/* 
.grid {
  display: grid;
  grid-gap: 1rem;
  grid-template-columns: 100%;
}

JS IMPLEMENTATION
.grid.aboveMin {
  grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
}

function observeGrid(gridNode) {
  // Feature detect ResizeObserver
  if ('ResizeObserver' in window) {
    // Get the min value from data-min="[min]"
    const min = gridNode.dataset.min;
    // Create a proxy element to measure and convert
    // the `min` value (which might be em, rem, etc) to `px`
    const test = document.createElement('div');
    test.style.width = min;
    gridNode.appendChild(test);
    const minToPixels = test.offsetWidth;
    gridNode.removeChild(test);

    const ro = new ResizeObserver(entries => {
      for (let entry of entries) {
        // Get the element's current dimensions
        const cr = entry.contentRect;
        // `true` if the container is wider than the minimum
        const isWide = cr.width > minToPixels;
        // toggle the class conditionally
        gridNode.classList.toggle('aboveMin', isWide);
      }
    });

    ro.observe(gridNode);
  }
}
*/